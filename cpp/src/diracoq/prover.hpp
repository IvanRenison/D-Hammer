// The function to process the command ast and operate the kernel

#pragma once

#include <iostream>
#include <fstream>
#include "trace2coq.hpp"
#include "calculus.hpp"

namespace diracoq {
    
    class Prover {
    protected:
        Kernel kernel;
        std::ostream& output;
        std::string coq_code;
        bool gen_coq;

        std::ofstream coq_file;


    protected:
        bool check_id(const astparser::AST& ast) {
            if (ast.children.size() != 0) {
                output << "Error: the identifier is not valid." << std::endl;
                output << "In the command: " << ast.to_string() << std::endl;
                return false;
            }
            return true;
        }

    public:
        Prover(std::ostream& _output = std::cout, bool _gen_coq = false, std::string coq_file_path = "") : output(_output) {
            if (coq_file_path != "") {
                // Open using 'w' mode
                coq_file.open(coq_file_path);
                if (!coq_file.is_open()) {
                    throw std::runtime_error("Error: cannot open the file \'" + coq_file_path + "\'.");
                }
                _gen_coq = true;
            }

            gen_coq = _gen_coq;

            if (gen_coq) {
                coq_code = "(* Certified Proof Generated by Diracoq *)\n\n";
            }

        }

        ~Prover() {
            if (coq_file.is_open()) {
                coq_file.close();
            }
        }
        
        const std::string& get_coq_code() const {
            return coq_code;
        }

        void append_coq_code(const std::string& extra_code) {
            coq_code += extra_code;
            if (coq_file.is_open()) {
                coq_file << extra_code;
                // flush the buffer
                coq_file.flush();
            }
        }

        inline bool process(const std::string& code) {
            auto ast = astparser::parse(code);
            if (ast.has_value()) {
                return process(ast.value());
            }
            else{
                output << "Error: the code is not valid." << std::endl;
                return false;
            }
        }

        bool process(const astparser::AST& ast);

        inline bool check_eq(const std::string& codeA, const std::string& codeB) {
            auto astA = astparser::parse(codeA);
            auto astB = astparser::parse(codeB);
            if (astA.has_value() and astB.has_value()) {
                return check_eq(astA.value(), astB.value());
            }
            else{
                output << "Error: the code is not valid." << std::endl;
                return false;
            }

        }
        
        /**
         * @brief Checks whether the two terms are equal. Return the result as a boolean.
         * 
         * @param codeA 
         * @param codeB 
         * @return true 
         * @return false 
         */
        bool check_eq(const astparser::AST& codeA, const astparser::AST& codeB);
    };

} // namespace diracoq